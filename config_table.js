import * as cohoard from "./pkg/cohoard.js";

import { Config } from "./pkg/cohoard.js";

/**
 * Manages the `<table>` which contains the UI for editing the Config data.
 */
export class ConfigTable {
    constructor(element, columns, body) {
        this.element = element;
        this.columns = columns;
        this.body = body;
        this.table = make_table_node(columns, body.length);
        element.appendChild(this.table);
    }

    /**
     * Mount a config table on the given element. Attempts to use localStorage to fill in the initial
     * table inputs.
     * @param {HTMLElement} element The element to mount the table to
     * @param {Array<string>} init_cols The initial column headers to generate.
     * May generate more columns if localStorage has more columns saved
     * @param {int} num_rows The minimum number of rows to generate
     * May generate more rows if localStore has more rows saved.
     * @returns {ConfigTable}
    */
    static mount(element, init_cols, num_rows) {
        // JS has some slightly annoying behavior with arrays. See below link.
        // https://stackoverflow.com/questions/41121982/strange-behavior-of-an-array-filled-by-array-prototype-fill
        let body = Array.from(Array(num_rows), () => Array(init_cols.length).fill(""));
        let table = new ConfigTable(element, init_cols, body);
        return table;
    }

    /** Save the table to localStorage */
    save_table() {
        console.log("TODO - save_table");
    }

    /**
     * Get a Cohoard-usable Config object from the data represented by the table.
     * @returns {Config}
     */
    get cohoard_config() {
        return cohoard_config_from_table(this.table);
    }
}

/**
 * Generates a `<table>` of the config data
 * @param {Array<string>} keys The columns headers that will be generated
 * @param {int} num_people The number of rows to generate
 * @returns {HTMLTableElement} The generated `table`.
 */
function make_table_node(keys, num_people) {
    let table = document.createElement("table");

    let header_row = document.createElement("tr");
    header_row.setAttribute("class", "config-row-header");
    for (const key of keys) {
        let cell;
        if (key == "key") {
            cell = h("th", {}, key);
        } else {
            cell = td_input("th", key, "key name");
        }

        header_row.appendChild(cell);
    }

    table.appendChild(header_row);

    for (const x of Array(num_people).keys()) {
        let row = document.createElement("tr");
        for (const key of keys) {
            row.appendChild(td_input("td", "", key));
        }
        table.appendChild(row);
    }

    return table;
}

/**
 * Takes the user-displayed table and turns it into an intenal Config object.
 * @param {HTMLTableElement} table The table to generate the config from. 
 * This needs to be a table generated by `make_table_node`.
 * @returns {Config} the config specified by the table.
 */
function cohoard_config_from_table(table) {
    assert_html_node(table, "table");
    let keys = [];
    let first_row = table.rows[0];
    for (let cell of first_row.cells) {
        assert_html_node(cell, "th");
        if (is_html_node(cell.firstChild, "input")) {
            keys.push(cell.firstChild.value);
        } else {
            keys.push("key");
        }
    }

    let people = [];
    row_loop: for (let row of table.rows) {
        // Skip the header rows
        if (row.rowIndex == 0) {
            continue;
        }
        let person = {}
        cell_loop: for (let cell of row.cells) {
            assert_html_node(cell, "td");
            assert_html_node(cell.firstChild, "input");
            let cell_key = keys[cell.cellIndex];
            let cell_value = cell.firstChild.value;
            if (cell_value == "") {
                if (cell_key == "key") {
                    // If the key doesn't exist, don't create a person at all
                    // (Cohoard requires the key to be set)
                    continue row_loop;
                } else {
                    // Don't set the property if the input is blank.
                    // This allows Cohoard to use a default value instead of thinking
                    // the property is set to the empty string.
                    continue cell_loop;
                }
            } else {
                person[cell_key] = cell_value;
            }
        }
        people.push(person);
    }
    let config_json = JSON.stringify({ people });
    return cohoard.load_config(config_json);
}

/** Constructs HTML elements
* @param {string} tag - The tag of the HTML element
* @param {object} attrs -A dictionary of the attributes of the element
* whose keys are the attribute names and the values are the attribute values.
* Note that the "value" key (a key whose name is literally "value") is
* special--this sets the `node.value` property instead of setting an attribute.
* @param {string | HTMLElement | Array<string | HTMLElement>} [body] - The body of the HTML element.
* @returns {HTMLElement} - The constructed HTML element
* You can recursively call `h` to achieve nested objects.
* Example:
* ```javascript
* h("div", { class: "foo" }, [
*   h("h1", { id: "bar" }, "Hello!"),
*   h("p", {}, "World!"),
* ])
* ```
* This produces the following HTML
* ```html
* <div class="foo">
*    <h1 id="bar">Hello!</h1>
*    <p>World!<p>
* </div>
* ```
*/
function h(tag, attrs, body) {
    const element = document.createElement(tag);
    for (const [k, v] of Object.entries(attrs)) {
        // Special-case the value and have it set the actual node value
        if (k == "value") {
            element.value = v;
        } else {
            element.setAttribute(k, v);
        }
    }

    if (body == undefined) {

    } else if (Array.isArray(body)) {
        element.append(...body);
    } else {
        element.append(body);
    }
    return element;
}

/**
 * Return a `td` or `th` cell containing a text input.
 * @param {"td" | "th"} cell_type - Determines whether if the cell is a data or header cell.
 * @param {string} value - The initial text of the text input
 * @param {string} placeholder - The placeholder text for the text input
 * @returns {HTMLTableCellElement} - The table cell containing the text input
 * The specific HTML returned looks like this:
 * ```html
 * <td>
 *     <input type="text">value</input>
 * </td>
 * ```
 */
function td_input(cell_type, value, placeholder) {
    return h(cell_type, {},
        h("input", { type: "text", placeholder, value })
    );
}

/**
 * @param {any} object 
 * @param {string} name The HTML element name to check for
 * @returns {bool} Returns true if `object` is an HTML element of type `name`.
 */
function is_html_node(object, name) {
    console.assert(name);
    if (object.tagName == undefined) {
        return false;
    }
    return object.tagName.toLowerCase() == name.toLowerCase();
}

/**
 * @param {any} object 
 * @param {string} name The HTML element name to check for
 */
function assert_html_node(object, name) {
    console.assert(name);
    if (!is_html_node(object, name)) {
        let tagName = object.tagName.toLowerCase();
        console.error(`object ${object} expected to be HTML node of type ${name}. Got ${tagName} instead.`);
        console.log(object.outerHTML);
    }
}
